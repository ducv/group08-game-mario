final TMXTiledMap tmxTiledMap = this.mTMXTiledMap;

		final int tilesHorizontal = this.mTileColumns;

		final int column = this.mTilesAdded % tilesHorizontal;
		final int row = this.mTilesAdded / tilesHorizontal;

		final TMXTile[][] tmxTiles = this.mTMXTiles;

		final ITextureRegion tmxTileTextureRegion;
		if(pGlobalTileID == 0) {
			// it's a transparent tile
			tmxTileTextureRegion = null;
		} else {
			tmxTileTextureRegion = tmxTiledMap.getTextureRegionFromGlobalTileID(pGlobalTileID);
		}
		final int tileHeight = this.mTMXTiledMap.getTileHeight();
		final int tileWidth = this.mTMXTiledMap.getTileWidth();

		if (tmxTileTextureRegion != null) {
			// Unless this is a transparent tile, setup the texture
			if (this.mTexture == null) {
				this.mTexture = tmxTileTextureRegion.getTexture();
				super.initBlendFunction(this.mTexture);
			} else {
				if (this.mTexture != tmxTileTextureRegion.getTexture()) {
					throw new AndEngineRuntimeException("All TMXTiles in a TMXLayer ("
							+ mName + ") need to be in the same TMXTileSet.");
				}
			}
		}
		final TMXTile tmxTile = new TMXTile(pGlobalTileID, column, row, tileWidth, tileHeight, tmxTileTextureRegion);
		tmxTiles[row][column] = tmxTile;

		if (pGlobalTileID != 0) {
			this.setIndex(this.getSpriteBatchIndex(column, row));
			this.drawWithoutChecks(tmxTileTextureRegion, tmxTile.getTileX(), tmxTile.getTileY(), tileWidth, tileHeight, Color.WHITE_ABGR_PACKED_FLOAT);
			this.submit(); // TODO Doesn't need to be called here, but should rather be called in a "init" step, when parsing the XML is complete.

			/* Notify the ITMXTilePropertiesListener if it exists. */
			if(pTMXTilePropertyListener != null) {
				final TMXProperties<TMXTileProperty> tmxTileProperties = tmxTiledMap.getTMXTileProperties(pGlobalTileID);
				if(tmxTileProperties != null) {
					pTMXTilePropertyListener.onTMXTileWithPropertiesCreated(tmxTiledMap, this, tmxTile, tmxTileProperties);
				}
			}
		}

		this.mTilesAdded++;